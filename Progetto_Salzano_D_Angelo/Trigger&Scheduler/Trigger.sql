--Trigger che confronta due abbonamenti
--Nel caso in cui i due abbonamenti, effettuati dallo stesso cliente, hanno stesso nome
--e stesse date d'inizio e di fine, allora lancia un errore per cui non si potrà inserire ulteriormente
--quell'abbonamento in quelle date

CREATE OR REPLACE TRIGGER UN_SOLO_ABB
BEFORE INSERT ON EFFETTUA
FOR EACH ROW
DECLARE
INVALID_SUB EXCEPTION;
SUB_NAME EFFETTUA.NOME_ABBONAMENTO%TYPE; 
USERNM EFFETTUA.USERNAME%TYPE;
SUB BOOLEAN := FALSE; --FLAG

BEGIN
SELECT NOME_ABBONAMENTO, USERNAME INTO SUB_NAME, USERNM
FROM EFFETTUA
WHERE NOME_ABBONAMENTO = :NEW.NOME_ABBONAMENTO AND
DATA_INIZIO_ABB = :NEW.DATA_INIZIO_ABB AND
DATA_FINE_ABB = :NEW.DATA_FINE_ABB AND
USERNAME = :NEW.USERNAME;

--CONFRONTA DUE ABBONAMENTI, SE QUELLO INSERITO E' DIVERSO DA QUELLO PRECEDENTEMENTE EFFETTUATO
--LA FLAG SARA' TRUE, ALTRIMENTI LANCIA L'ERRORE 
IF SUB_NAME != :NEW.NOME_ABBONAMENTO AND USERNM = :NEW.USERNAME THEN
SUB:=TRUE;
ELSE
RAISE INVALID_SUB;
END IF;

--SE IL NUOVO ABBONAMENTO INSERITO HA DATE DIFFERENTI DA QUELLO GIA' INSERITO IN PRECEDENZA,
--LA FLAG SARA' TRUE,ALTRIMENTI LANCIA L'ERRORE
IF SYSDATE != :NEW.DATA_INIZIO_ABB AND SYSDATE != :NEW.DATA_FINE_ABB THEN
SUB:=TRUE;
ELSE
RAISE INVALID_SUB;
END IF;

--GESTIONE DELLE VARIE ECCEZIONI 
EXCEPTION
WHEN INVALID_SUB THEN
RAISE_APPLICATION_ERROR(-20008,'ABBONAMENTO CON DATE E NOME IDENTICI AL PRECEDENTE');
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('ABBONAMENTI CONFRONTATI,NESSUN ABBONAMENTO TROVATO');
WHEN TOO_MANY_ROWS THEN
RAISE_APPLICATION_ERROR(-20008,'ABBONAMENTO CONFRONTATO,RISCONTRI CON DATI NON DEL CLIENTE');
WHEN OTHERS THEN
RAISE_APPLICATION_ERROR(-20008,'PROBLEMA RISCONTRATO');
END;

---------------------------------------------------------------------

--Trigger che controlla se una carta per effettuare acquisti sia scaduta o no,
--nel caso in cui la carta sia scaduta lancia un errore 

CREATE OR REPLACE TRIGGER CARTA_SCADUTA
BEFORE INSERT ON CARTA
FOR EACH ROW
DECLARE 
INVALID_CARD EXCEPTION;
SCADUTA CARTA.SCADENZA%TYPE;

BEGIN 
--SE LA DATA DI SISTEMA E' MAGGIORE ALLA DATA DELLA SCADENZA DELLA CARTA,ALLORA
--E' IMPOSSIBILE UTILIZZARE QUELLA CARTA E VERRA' LANCIATO UN ERRORE 
IF :NEW.SCADENZA < SYSDATE THEN 
RAISE INVALID_CARD;
END IF;

--GESTIONE DELLE ECCEZIONI 
EXCEPTION
WHEN INVALID_CARD THEN
RAISE_APPLICATION_ERROR(-20008,'CARTA SCADUTA,IMPOSSIBILE INSERIRLA');
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('SCADENZA CONTROLLATA,CARTA NON SCADUTA');
WHEN TOO_MANY_ROWS THEN
RAISE_APPLICATION_ERROR(-20008,'PIU SCADENZE CONFRONTATE,CARTA NON SCADUTA');
WHEN OTHERS THEN
RAISE_APPLICATION_ERROR(-20008,'CARTA SCADUTA,IMPOSSIBILE INSERIRLA');
END;

---------------------------------------------------------------------

--Trigger che controlla se un cliente può eseguire il reso.Esso è possibile se
--la data in cui lo richiede è minore a 31 giorni da quando ha effettuato l'acquisto.
--Nel caso contrario verrà lanciato un errore

CREATE OR REPLACE TRIGGER RESO
BEFORE INSERT ON ACQUISTO
FOR EACH ROW 
DECLARE 
INVALID_RESO EXCEPTION;
DATA_RESO ACQUISTO.DATA_ACQUISTO%TYPE;
COD_ACQUISTO ACQUISTO.CODICE_ACQUISTO%TYPE;
RES BOOLEAN := FALSE; --FLAG

BEGIN
SELECT DATA_ACQUISTO, CODICE_ACQUISTO INTO DATA_RESO, COD_ACQUISTO
FROM ACQUISTO
WHERE DATA_ACQUISTO = :NEW.DATA_ACQUISTO AND
CODICE_ACQUISTO = :NEW.CODICE_ACQUISTO;

--SE TRA LA DATA D'ACQUISTO E LA DATA DI SISTEMA SONO PASSATI MENO DI 31 GIORNI,
--ALLORA E' POSSIBILE ESEGUIRE IL RESO, ALTRIMENTI VERRA' LANCIATO UN ERRORE
IF (SYSDATE - :NEW.DATA_ACQUISTO) < 31 AND
COD_ACQUISTO = :NEW.CODICE_ACQUISTO THEN
RES:=TRUE;
ELSE
RAISE INVALID_RESO;
END IF;

--GESTIONE DELLE ECCEZIONI 
EXCEPTION
WHEN INVALID_RESO THEN 
RAISE_APPLICATION_ERROR(-20008,'31 GIORNI O PIU,IMPOSSIBILE ESEGUIRE IL RESO');
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('NUOVA DATA');
WHEN TOO_MANY_ROWS THEN
RAISE_APPLICATION_ERROR(-20008,'ULTERIORE DATA TROVATA');
WHEN OTHERS THEN
RAISE_APPLICATION_ERROR(-20008,'PROBLEMA RISCONTRATO');
END;

---------------------------------------------------------------------

--Trigger che controlla se un prodotto è già contenuto in un catalogo,
--e se ciò risultasse vero esso non può essere aggiunto ulteriormente
--all'interno di un altro catalogo

CREATE OR REPLACE TRIGGER UN_SOLO_CATALOGO
BEFORE INSERT ON PRODOTTO
FOR EACH ROW
DECLARE
INVALID_CATALOGO EXCEPTION;
CATALOGUE PRODOTTO.NOME_CATALOGO%TYPE;
PROD_CATALOG PRODOTTO.ID_PRODOTTO%TYPE;

BEGIN
SELECT NOME_CATALOGO, ID_PRODOTTO INTO CATALOGUE, PROD_CATALOG
FROM PRODOTTO
WHERE NOME_CATALOGO = :NEW.NOME_CATALOGO AND
ID_PRODOTTO = :NEW.ID_PRODOTTO;

--SE IL NOME DI UN PRODOTTO CORRISPONDE AD UN ALTRO PRODOTTO, CONTENUTO IN UN ALTRO CATALOGO,
--ALLORA SARA' IMPOSSIBILE INSERIRE QUEL PRODOTTO IN UN ALTRO CATALOGO
IF :NEW.NOME_CATALOGO = CATALOGUE AND :NEW.ID_PRODOTTO = PROD_CATALOG THEN
RAISE INVALID_CATALOGO;
END IF;

--GESTIONE DELLE ECCEZIONI 
EXCEPTION
WHEN INVALID_CATALOGO THEN
RAISE_APPLICATION_ERROR(-20008,'PRODOTTO GIA CONTENUTO IN UN CATALOGO');
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('PRODOTTO NON CONTENUTO IN NESSUN CATALOGO');
WHEN TOO_MANY_ROWS THEN
RAISE_APPLICATION_ERROR(-20008,'ULTERIORE PRODOTTO TROVATO');
WHEN OTHERS THEN
RAISE_APPLICATION_ERROR(-20008,'PROBLEMA RISCONTRATO');
END;


---------------------------------------------------------------------


--Trigger che gestisce i release day e che cerca di contenere il numero di release day presentati in un anno.
--Nel caso in cui i release day inseriti in un anno(in questo caso è stato preso come riferimento il 2022) 
--siano maggiori a 20, il contatore si fermerà e lancerà un errore

CREATE OR REPLACE TRIGGER RELEASE_YEAR
BEFORE INSERT ON RELEASE_DAY
FOR EACH ROW
DECLARE
INVALID_RELEASE EXCEPTION;
CONTATORE NUMBER;
ANNO_CORRENTE NUMBER;

BEGIN
SELECT EXTRACT (year FROM DATA_RELEASE) AS year, 
  COUNT(DATA_RELEASE) 
  INTO ANNO_CORRENTE, CONTATORE
FROM RELEASE_DAY
GROUP BY EXTRACT(year FROM DATA_RELEASE);

--SE DURANTE IL CORSO DELL'ANNO VERRANNO CONTATI PIU' DI 20 RELEASE DAY 
--VERRA' LANCIATO UN ERRORE
IF CONTATORE > 20
THEN
RAISE INVALID_RELEASE;
END IF;

--GESTIONE DELLE ECCEZIONI
EXCEPTION
WHEN INVALID_RELEASE THEN
RAISE_APPLICATION_ERROR(-20008,'TROPPE RELEASE PROGRAMMATE IN UN ANNO');
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('RELEASE NON TROVATA');
WHEN TOO_MANY_ROWS THEN
RAISE_APPLICATION_ERROR(-20008,'ULTERIORE RELEASE TROVATA');
WHEN OTHERS THEN
RAISE_APPLICATION_ERROR(-20008,'PROBLEMA RISCONTRATO');
END;

---------------------------------------------------------------------

--Trigger che gestisce il numero di scorte all'interno di un magazzino. Se il numero totale delle scorte 
--distribuite all'interno di quel magazzino sarà maggiore della capienza del magazzino stesso
--allora verrà lanciato un errore, che segnala che è stata oltrepassata la capienza

CREATE OR REPLACE TRIGGER CAPACITA_MAX
BEFORE INSERT ON E_CONTENUTA_IN
FOR EACH ROW
DECLARE
INVALID_CAPACITA EXCEPTION;
QUANTITA E_CONTENUTA_IN.QUANTITA_DISTRIB%TYPE;
CAPIENZA MAGAZZINO.CAPIENZA%TYPE;

BEGIN
SELECT SUM(E_CONTENUTA_IN.QUANTITA_DISTRIB),MAX(MAGAZZINO.CAPIENZA) INTO QUANTITA,CAPIENZA
FROM E_CONTENUTA_IN JOIN MAGAZZINO ON E_CONTENUTA_IN.NUMERO_MAGAZZINO = MAGAZZINO.NUMERO_MAGAZZINO
GROUP BY E_CONTENUTA_IN.NUMERO_MAGAZZINO
HAVING E_CONTENUTA_IN.NUMERO_MAGAZZINO = :NEW.NUMERO_MAGAZZINO;

--SE LA SOMMA TRA LA QUANTITA' PRESENTE IN MAGAZZINO E LA QUANTITA' DA INSERIRE
--SUPERA LA CAPIENZA DEL MAGAZZINO
--ALLORA SARA' IMPOSSIBILE INSERIRE ALTRE SCORTE 
IF (QUANTITA + :NEW.QUANTITA_DISTRIB) > CAPIENZA
THEN
RAISE INVALID_CAPACITA;
END IF;

--GESTIONE DELLE ECCEZIONI
EXCEPTION
WHEN INVALID_CAPACITA THEN
RAISE_APPLICATION_ERROR(-20008,'SCORTE SUPERIORI ALLA CAPIENZA');
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('SPAZIO DISPONIBILE');
WHEN TOO_MANY_ROWS THEN
RAISE_APPLICATION_ERROR(-20008,'PIU SCORTE CONTENUTE');
WHEN OTHERS THEN
RAISE_APPLICATION_ERROR(-20008,'PROBLEMA RISCONTRATO');
END;







